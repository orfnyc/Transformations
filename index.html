<!DOCTYPEHTML>
<html>
    <head>
        <style>
            canvas
            {
                background-color: black;
            }
        </style>
        <script src="mathComponents.js" async></script>
        <script>
            let projectionMatrix, canvas, vectors, context, scale, originX, originY, objects, o2, rotation;
            let userInputTest, transformationForm, matrixForm;
            function initialize()
            {
                projectionMatrix = new Matrix([
                    new Vector([1, 0]),
                    new Vector([0, 1]),
                    new Vector([0, 0])
                ])
                canvas = document.getElementById("canvas");
                userInputTest = document.getElementById("tester");
                transformationForm = document.getElementById("transformationForm");
                transformationForm.addEventListener("submit", (e) => 
                {
                    e.preventDefault();
                    console.log(matrixForm);
                    let v1 = new Vector([matrixForm[0].value, matrixForm[3].value, matrixForm[6].value]);
                    let v2 = new Vector([matrixForm[1].value, matrixForm[4].value, matrixForm[7].value]);
                    let v3 = new Vector([matrixForm[2].value, matrixForm[5].value, matrixForm[8].value]);
                    transformScene(new Matrix([v1, v2, v3]));
                    drawScene();
                });
                document.addEventListener('keydown', () =>  
                {
                    let code = event.code;
                    if (code === "KeyA")
                    {
                        for (let i = 0; i < objects.length; i++)
                        {
                            objects[i].rotate(-1, 1);
                        }
                        drawScene();
                    }
                    else if (code === "KeyD")
                    {
                        for (let i = 0; i < objects.length; i++)
                        {
                            objects[i].rotate(1, 1);
                        }
                        drawScene();
                    }
                    if (code === "KeyW")
                    {
                        for (let i = 0; i < objects.length; i++)
                        {
                            objects[i].rotate(1, 2);
                        }
                        drawScene();
                    }
                    else if (code === "KeyS")
                    {
                        for (let i = 0; i < objects.length; i++)
                        {
                            objects[i].rotate(-1, 2);
                        }
                        drawScene();
                    }
                }, false);
                context = canvas.getContext("2d");
                context.lineWidth = 2;
                scale = 32;
                frameOriginX = 256;
                frameOriginY = 256;
                objects = [];
                rotation = new Vector([0, 0, 0]);
                origin = new Vector([0, 0, -16])
                objects.push(new Cube(3));
                buildMatrixForm();
                drawScene();
            }

            function buildMatrixForm()
            {
                matrixForm = [];
                for (let i = 0; i < 3; i++)
                {
                    for (let j = 0; j < 3; j++)
                    {
                        let el = document.createElement("input");
                        el.setAttribute("step", "0.01");
                        el.setAttribute("type", "number");
                        transformationForm.appendChild(el);
                        matrixForm.push(el);
                    }
                    transformationForm.appendChild(document.createElement("br"));
                }
                console.log(matrixForm);
            }
            function drawVector(vector)
            {
                let v = vector.transform(projectionMatrix);
                context.beginPath();
                context.moveTo(frameOriginX, frameOriginY);
                context.lineTo(frameOriginX + v.elements[0]*scale, frameOriginY - v.elements[1]*scale);
                context.strokeStyle = "#ff0000";
                context.stroke();
            }

            function drawEdge(edge)
            {
                let start = origin.add(edge.start).transform(projectionMatrix)
                let end = origin.add(edge.end).transform(projectionMatrix);
                context.beginPath();
                context.moveTo(frameOriginX + start.elements[0]*scale, frameOriginY - start.elements[1]*scale);
                context.lineTo(frameOriginX + end.elements[0]*scale, frameOriginY - end.elements[1]*scale);
                let grd = context.createLinearGradient(frameOriginX + start.elements[0]*scale, 
                                                        frameOriginY - start.elements[1]*scale, 
                                                        frameOriginX + end.elements[0]*scale, 
                                                        frameOriginY - end.elements[1]*scale);
                // 255, 200, 75
                // 50, 0, 80
                let r = (255+50) / 2 + edge.start.elements[2] * (-255+50)/12
                let g = (200+0) / 2 + edge.start.elements[2] * (-200+0)/12
                let b = (75+80) / 2 + edge.start.elements[2] * (-75+80)/12
                grd.addColorStop(0, `rgb(${r}, ${g}, ${b})`);
                r = (255+50) / 2 + edge.end.elements[2] * (-255+50)/12
                g = (200+0) / 2 + edge.end.elements[2] * (-200+0)/12
                b = (75+80) / 2 + edge.end.elements[2] * (-75+80)/12
                grd.addColorStop(1, `rgb(${r}, ${g}, ${b})`);
                context.strokeStyle = grd;
                context.stroke();
            }

            // Possible Orientations
            // 0: Segments have no intersection (parallel or otherwise)
            // 1: Segments have 1 intersection, edge 1 is in front
            // 2: Segments have 1 intersection, edge 2 is in front
            // 3: Segments have >1 insection
            function orientation(edge1, edge2)
            {
                // Important information about line each edge is a segment of
                // TO DO: Special case for vertical line
                let m1 = (edge1.start.elements[1] - edge1.end.elements[1]) / (edge1.start.elements[0] - edge1.end.elements[0]);
                let m2 = (edge2.start.elements[1] - edge2.end.elements[1]) / (edge2.start.elements[0] - edge2.end.elements[0]);
                // y = mx + b --> b = y - mx
                let b1 = edge1.start.elements[1] - m1 * edge1.start.elements[0];
                let b2 = edge2.start.elements[1] - m2 * edge2.start.elements[0];
                // Same slope
                if (m1 == m2)
                {
                    if (b1 == b2)
                    {
                        // colinear
                        if (inRange(edge1.start.elements[0], edge2.start.elements[0], edge2.end.elements[0]) ||
                            inRange(edge1.end.elements[0], edge2.start.elements[0], edge2.end.elements[0]))
                        {
                            if (edge1.start.elements[2] > edge2.start.elements[2])
                            {
                                return 2;
                            }
                            else if (edge1.start.elements[2] < edge2.start.elements[2])
                            {
                                return 1;
                            }
                            return 3;
                        }
                        return 0;
                    }
                    else
                    {
                        // parallel
                        return 0;
                    }
                }
                // Find point of intersection of lines
                // y = m1 * x + b1 --> y - m1 * x = b1
                // y = m2 * x + b1 --> y - m2 * x = b2
                let y = ((b2*m1) - (m2*b1)) / (m1 - m2);
                let x = (-b1+y) / m1;
                // Check if (x, y) is on both segments
                if (!(inRange(x, edge1.start.elements[0], edge1.end.elements[0]) &&
                    inRange(x, edge2.start.elements[0], edge2.end.elements[0]) &&
                    inRange(y, edge1.start.elements[1], edge1.end.elements[1]) &&
                    inRange(y, edge2.start.elements[1], edge2.end.elements[1])))
                // if not: return 0
                {
                    return 0;
                }
                // if: find and compare the z-coordinates
                let z1; let z2;
                // let slope = change in z / change in x
                slope1 = (edge1.start.elements[2] - edge1.end.elements[2]) / (edge1.start.elements[0] - edge1.end.elements[0]);
                slope2 = (edge2.start.elements[2] - edge2.end.elements[2]) / (edge2.start.elements[0] - edge2.end.elements[0]);
                // equation for a line Z - Zn = slope(M - Mn) --> Z = slope(M - Mn) + Zn
                z1 = slope1 * (x - edge1.start.elements[0]) + edge1.start.elements[2];
                z2 = slope2 * (x - edge2.start.elements[0]) + edge2.start.elements[2];
                if (z1 <= z2) return 1;
                return 2;
            }

            function drawScene()
            {
                // Clear canvas
                context.clearRect(0, 0, canvas.width, canvas.height);
                // Add all edges in scene to queue
                let queue = [];
                for (let i = 0; i < objects.length; i++)
                {
                    for (let j = 0; j < objects[i].edges.length; j++)
                    {
                        let edge = objects[i].edges[j].copy();
                        edge.rotate(rotation.elements[0], 0);
                        edge.rotate(rotation.elements[1], 1);
                        edge.rotate(rotation.elements[2], 2);
                        queue.push(edge);
                    }
                }
                console.log(queue);
                // Place elements in queue into drawing order
                // toDraw ordered by furthest to closest
                let toDraw = [];
                while (queue.length > 0)
                {
                    let edge = queue.shift()
                    // start with the first
                    let index = 0;
                    // increase position while edge is not behind edge at position
                    while (index < toDraw.length && orientation(edge, toDraw[index]) != 2)
                    {
                        index++;
                    } 
                    toDraw.splice(index, 0, edge);
                }
                for (let i = 0 ; i < toDraw.length; i++)
                {
                    drawEdge(toDraw[i]);
                }
            } 

            function inRange(x, bound1, bound2)
            {
                let min = Math.min(bound1, bound2);
                let max = Math.max(bound1, bound2);
                return (min <= x && x <= max)
            }

            function transformScene(matrix)
            {
                for (let i = 0; i < objects.length; i++)
                {
                    for (let j = 0; j < objects[i].edges.length; j++)
                    {
                        objects[i].edges[j].start = objects[i].edges[j].start.transform(matrix);
                        objects[i].edges[j].end = objects[i].edges[j].end.transform(matrix);
                    }
                }
            }

            function test(axis)
            {
                
            }

            function test2()
            {
                for (let i = 0; i < objects.length; i++)
                {
                    objects[i].rotate(9, 1);
                }
                drawScene();
            }

        </script>
    </head>
    <body onload="initialize();">
        <canvas id="canvas" width="512" height="512"></canvas>
        <form id="transformationForm">
            <button type="submit">Submit</button> <br>
        </form>
        <button onclick="objects=[new Cube(3)]; drawScene();">Reset Cube</button>
        <button onclick="objects=[new Dodecahedron()]; drawScene();">Reset Dodecahedron</button>
    </body>
</html>